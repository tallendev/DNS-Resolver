package edu.wcu.cs.agora.allen.DnsResolver;

/**
 * Resolver is a Singleton used for resolving domain addresses of certain types,
 * similar to the program DiG. It is a Singleton because the Resolver object
 * itself is stateless.
 *
 * @author Tyler Allen
 * @version 10/07/2013
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Resolver
{
    /** The maximum size of a UDP response message, in bytes, from RFC 1035*/
    public final static int UDP_BUFF = 1024;
    /** The timeout waiting for TCP and UDP responses. */
    public final static int TIMEOUT  = 3000;


    /** This field holds the only instance of the resolver class.*/
    private static Resolver resolver = null;

    /**
     * This method is the only way to get an instance of this class. No
     * instances of this class exist until this method has been called for the
     * first time. Otherwise, this method always returns the same object.
     * @return The only instance of this object available.
     */
    public static Resolver getInstance()
    {
        if (null == resolver)
            resolver = new Resolver();
        return resolver;
    }

    /**Empty with private access modifier to restrict outside classes making an
     * instance of this class.*/
    private Resolver()
    {
    }

    /**
     * This method sends a UDP packet to the requested DNS server.  If a
     * response is received, a Response object is generated and returned.
     * @param request The request to make to the DNS server.
     * @return The Response received from the DNS server.
     * @throws IOException Exceptions generated by UDP sockets such as timeout,
     *                     as well as DnsExceptions and TruncatedUdpExceptions.
     */
    public Response makeUdpRequest(Request request) throws IOException
    {
        /* This list will contain our response from the DNS server.*/
        List<Byte> list = getPrefList();
        try (DatagramSocket socket = new DatagramSocket())
        {
            socket.setSoTimeout(TIMEOUT);
            /* Get a UDP Request Packet from Request. */
            socket.send(request.getRequestPacket());

            /* Create packet to await response.*/
            byte[] inputBuffer = new byte[UDP_BUFF];
            DatagramPacket responsePacket = new DatagramPacket(inputBuffer,
                                                               UDP_BUFF);
            socket.receive(responsePacket);
            /* Convert response to list. */
            list = Util.byteArrayToList(inputBuffer, list);
        }
        return new ResponseGenerator(list,
                                     request.getIdentifier()).getResponse();
    }

    /**
     * Attempts to make a TCP connection and send a TCP DNS request to the
     * server specified in the parameter Request.
     * @param request The request to send to the DNS server.
     * @return The Response object generated from a successful DNS request.
     * @throws IOException Socket and Socket Timeout exceptions, as well as
     *                     DNS Exceptions in the event malformed packets are
     *                     received.
     */
    public Response makeTcpRequest (Request request) throws IOException
    {
        List<Byte> list;
        try (Socket socket = request.getTcpSocket();
             InputStream in = socket.getInputStream();
             OutputStream out = socket.getOutputStream())
        {
            socket.setSoTimeout(TIMEOUT);
            list = getPrefList();
            /* Get the RawRequest from Response. */
            byte[] tcpRequest = request.getRawTcpRequest();
            /* Make sure that the output stream is flushed. */
            out.write(tcpRequest);
            out.flush();
            socket.shutdownOutput();
            int count;
            /* Read bytes from output stream until none are left.*/
            while((count = in.read())> 0)
                list.add((byte) count);
            /* In the event no bytes are read, we throw a new DNS exception
            *  due to the lack of response. This indicates that TCP DNS requests
            *  are not available on that server. */
            if (list.size() == 0)
                throw new DnsException("TCP Port 83 appears to be" +
                                       " unresponsive.");
        }
        return new ResponseGenerator(list, request.getIdentifier()).getResponse();
    }

    /**
     * Returns the optimal list for sending in to a RequestGenerator.
     * @return An empty list.
     */
    private List<Byte> getPrefList()
    {
        return new ArrayList<>();
    }

    /**
     * This method exists to prevent shallow clones of this object from being
     * created. Simply throws CloneNotSupported.
     * @return This method does not actually return.
     * @throws CloneNotSupportedException This method throws this exception
     * every time it is called.
     */
    @Override
    public Resolver clone() throws CloneNotSupportedException
    {
        throw new CloneNotSupportedException("Clone is not supported on the " +
                                             "resolver object.");
    }

    /**
     * This is a DNS Response object. It contains lists of data extracted from
     * a DNS Packet. The only class that should create these is
     * ResponseGenerator. This class may be improved later to include other
     * parts of the DNS packet.
     */
    public class Response
    {
        /** List of Queries from the "Query" section of the DNS packet. */
        private List<Record> queries;
        /** List of Records from the "Answer" section of a DNS packet. */
        private List<Record> answers;
        /** List of Records from the "Authority" section of a DNS packet. */
        private List<Record> authority;
        /** List of Records from the "Additional" section of a DNS packet. */
        private List<Record> additional;

        /**
         * Protected constructor. Only ResponseGenerator should call this.
         * @param answers The List from the "Answers" section of the DNS packet.
         */
        protected Response(List<Record> queries, List<Record> answers,
                           List<Record> authority, List<Record> additional)
        {
            this.queries   = queries;
            this.answers   = answers;
            this.authority = authority;
            this.additional = additional;
        }

        /**
         * Returns the list of answers from this Response object.
         * @return The List of answers;
         */
        protected List<Record> getAnswers()
        {
            return answers;
        }

        protected List<Record> getQueries()
        {
            return queries;
        }

        protected List<Record> getAuthority()
        {
            return authority;
        }

        protected List<Record> getAdditional()
        {
            return additional;
        }
    }

    /**
     * Creates an intermediate object that makes a single Response out of a
     * response from a DNS request.
     */
    protected class ResponseGenerator
    {
        /** The length of a DNS header. */
        public final static int HEADER_LEN         = 12;
        /** One byte index. */
        public final static int ONE_BYTE           = 1;
        /** 2 byte indexes. */
        public final static int TWO_BYTES          = 2;
        /** 3 byte indexes. */
        public final static int THREE_BYTES        = 3;
        /** 4 byte indexes. */
        public final static int FOUR_BYTES         = 4;
        /** The size of the extra data after a SOA Record. */
        public final static int SOA_DATA           = 20;

        /** The location, in a DNS packet array, of the RA, TA, and QR fields.*/
        public final static int RA_TA_QR_INDEX     = 2;
        /** The location of the RCODE in a DNS Packet Array. */
        public final static int RCODE_INDEX        = 3;
        /** The first index of the two-byte QDCODE in a DNS Packet array.*/
        public final static int QDCODE_INDEX1      = 4;
        /** The second index of the two-byte question count
         *  in a DNS Packet array. */
        public final static int QDCODE_INDEX2      = 5;
        /** The first index of the two-byte answer in a DNS Packet array.*/
        public final static int ANCOUNT_INDEX1     = 6;
        /** The second index of the two-byte answer in a DNS Packet array.*/
        public final static int ANCOUNT_INDEX2     = 7;
        /** The first index of the two-byte answer in a DNS packet array. */
        public final static int ATCOUNT_INDEX1     = 8;
        /** The second index of the two-byte answer in a DNS packet array. */
        public final static int ATCOUNT_INDEX2     = 9;
        /** The first index of the two-byte additional field in a DNS packet
         * array. */
        public final static int ADCOUNT_INDEX1     = 10;
        /** The second index of the two-byte additional field in a DNS packet
         * array. */
        public final static int ADCOUNT_INDEX2     = 11;


        /** Acceptable byte configuration of the QR_and_RR field. This is
         * both the mask, and the configuration.*/
        public final static byte QR_AND_RR         = (byte) 0b10000001;
        /** This is the mask for the RA and RCODE fields. This must be applied
         *  before compared to the optimal configuration. */
        public final static byte RA_AND_RCODE_MASK = (byte) 0b10001111;
        /** Acceptable configuration of RA and RCODE. */
        public final static byte RA_AND_RCODE      = (byte) 0b10000000;
        /** Mask/Configuration for the truncaiton bit. We will throw a
         * truncated packet exception if this is set. */
        public final static byte TA                = (byte) 0b00000010;
        /** Determines if a byte could be a DNS_PTR. */
        public final static byte DNS_PTR           = (byte) 0b11000000;
        /** Cuts out the first two bits so that the following 14 in a two-byte
         * set can be converted to a short and followed. */
        public final static byte DNS_PTR_OFF       = (byte) 0b00111111;

        /** The current offset, showing our progression through the DNS
         *  packet.*/
        private int offset;
        /** The buffer containing the DNS information. */
        private List<Byte> buff;
        /** The response we are generating. */
        private Response response;

        /**
         * ResponseGenerators should only be created by DNSResolver. This
         * constructor does some small error checking to ensure that the DNS
         * packet received is acceptable for parsing, and then parses through
         * it to build a Response. If an invalid buffer is sent in, the results
         * would be undefined.
         * @param buffer The Buffer from a DNS Packet.
         * @param identifier The identifier from the request. This is used for
         *                   error checking, to verify this response has the
         *                   same ID as the one we sent in.
         * @throws IOException DnsExceptions and TruncatedPacketExceptions that
         *                     could be thrown due to malformed response
         *                     packets.
         */
        private ResponseGenerator (List<Byte> buffer, byte[] identifier)
                                   throws IOException
        {
            this.buff = buffer;
            List<Byte> id = buffer.subList(0, TWO_BYTES);
            int qrOpAaTcRd = buffer.get(RA_TA_QR_INDEX);
            int raZRcode = buffer.get(RCODE_INDEX);
            // Extract the values from these fields and converting them into
            // valid numbers.

            //The number of question fields.
            int qdCount = Util.bytesToShort(buffer.get(QDCODE_INDEX1),
                                            buffer.get(QDCODE_INDEX2));
            // The number of Answer fields.
            int anCount = Util.bytesToShort(buffer.get(ANCOUNT_INDEX1),
                                            buffer.get(ANCOUNT_INDEX2));
            int atCount = Util.bytesToShort(buffer.get(ATCOUNT_INDEX1),
                                            buffer.get(ATCOUNT_INDEX2));
            int adCount = Util.bytesToShort(buffer.get(ADCOUNT_INDEX1),
                                            buffer.get(ADCOUNT_INDEX2));

            verifyInput(id, identifier, qrOpAaTcRd, raZRcode);
            // Skip over the first 12 indexes as they are part of the header.
            offset = HEADER_LEN;
            response = new Response(getQueries(qdCount), makeAnswers(anCount),
                                    makeAuthority(atCount),
                                    makeAdditional(adCount));
        }

        private List<Record> makeAdditional(int adCount)
        {
            return makeAnswers(adCount);
        }

        /**
         * This section calculates the offset increase we need to make to
         * skip over the "Question" Section of the response packet.
         * @param qdCount The number of questions to skip over.
         */
        private List<Record> getQueries(int qdCount)
        {
            List<Record> queries = new LinkedList<>();
            for (int i = 0; i < qdCount; i++)
            {
                String name = formatDomainName(extractDomainField(offset));
                RecordType type = extractRecordType();
                short classType = extractClassType();
                queries.add(Record.recordFactory(name, type, classType, -1,
                                                 null));
            }
            return queries;
        }

        private RecordType extractRecordType()
        {
            RecordType type = RecordType.reverseTypeLookup(
                              Util.bytesToShort(buff.get(offset),
                              buff.get(offset + ONE_BYTE)));
            offset += TWO_BYTES;
            return type;
        }

        private short extractClassType()
        {
            short classType = Util.bytesToShort(buff.get(offset),
                                                buff.get(offset + ONE_BYTE));
            offset += TWO_BYTES;
            return classType;
        }

        private String formatDomainName(List<Byte> bytes)
        {
            return new String(Util.unboxBytes(bytes),
                             StandardCharsets.UTF_8);
        }

        private int extractTtl()
        {
            int ttl = Util.bytesToInt(buff.get(offset),
                                      buff.get(offset + ONE_BYTE),
                                      buff.get(offset + TWO_BYTES),
                                      buff.get(offset + THREE_BYTES));
            offset += FOUR_BYTES;
            return ttl;
        }

        private short extractRdLength()
        {
            short rdLen = Util.bytesToShort(buff.get(offset),
                                            buff.get(offset + ONE_BYTE));
            offset += TWO_BYTES;
            return rdLen;
        }

        /**
         * Returns the Response generated by this object. This object should be
         * dereferenced once the Response has been extracted, as there is no
         * further use.
         * @return The Response generated by this object.
         */
        public Response getResponse()
        {
            return response;
        }

        /**
         * This method checks over the header information and tries to verify
         * that we know how to understand it.
         * @param id The identifier that the DNS packet is expected to have.
         * @param identifier The actual identifier from the header.
         * @param qrOpAaTcRd The value of the qr opcode, AA, Truncated, and
         *                   Recursion Desired fields from the DNS packet.
         * @param raZRcode The recursion available, Z, and Rcode fields from
         *                 the DNS packet.
         * @throws IOException Could throw a DNSException if the packet is
         *                     malformed or we can not handle it.
         *                     TruncatedPacketException will be thrown if the
         *                     packet is Truncated.
         */
        private void verifyInput(List<Byte> id, byte[] identifier,
                                 int qrOpAaTcRd, int raZRcode)
                throws IOException
        {
            if (!(id.get(0).equals(identifier[0]) &&
                  id.get(1).equals(identifier[1]) &&
                  ((qrOpAaTcRd & QR_AND_RR) == QR_AND_RR) &&
                  ((raZRcode & RA_AND_RCODE_MASK) == RA_AND_RCODE)))
            {
                throw new DnsException("Error in Response from DNS Server");
            }
            if ((qrOpAaTcRd & TA) == TA)
            {
                throw new TruncatedUdpPacketException("Packet response from" +
                                                      " DNS Server was " +
                                                      "Truncated.");
            }
        }

        private List<Record> makeAuthority(int atCount)
        {
            List<Record> list = new LinkedList<>();
            for (int i = 0; i < atCount; i++)
            {
                List<Byte> temp = extractDomainField(offset);
                String name = formatDomainName(temp);
                RecordType type = extractRecordType();
                short classType = extractClassType();
                int ttl = extractTtl();
                short rdlength = extractRdLength();
                List<Byte> rdata = buff.subList(offset, offset + rdlength);
                List<Byte> tempRdata = null;
                if (type.isRdataExpandable())
                {
                    tempRdata = extractDomainField(offset);
                }
                else
                {
                    tempRdata = rdata;
                    offset += rdlength;
                }
                if (type == RecordType.SOA)
                {
                    tempRdata.add((byte) '\t');
                    tempRdata.addAll(extractDomainField(offset));
                    tempRdata.addAll(buff.subList(offset, offset + SOA_DATA));
                }
                rdata = tempRdata;
                // We subtract off rdlength so that we don't accidently incur
                //an increase in offset by calling the expandRdata method.
                list.add(Record.recordFactory(name, type, classType, ttl,
                                              rdata));
            }
            // Removes all null elements from this list. Null elements will be
            // returned if record type is not supported.
            while (list.remove(null));
            return list;
            //return this.makeAnswers(atCount);
        }

        /**
         * This method pulls the "Answer" section from the DNS packet. It will
         * also generate a response, as currently the Answers section is the
         * only section we include.
         * @param anCount The number of answers to search for.
         * @return The Response generated by this object.
         */
        private List<Record> makeAnswers(int anCount)
        {
            List<Record> list = new LinkedList<>();
            for (int i = 0; i < anCount; i++)
            {
                List<Byte> temp = extractDomainField(offset);
                String name = formatDomainName(temp);
                RecordType type = extractRecordType();
                short classType = extractClassType();
                int ttl = extractTtl();
                short rdlength = extractRdLength();
                List<Byte> rdata = new LinkedList<Byte>();
                //ifSoa(type, rdata);
                rdlength = ifMX(type, rdata, rdlength);
                if (type.isRdataExpandable())
                {
                    rdata.addAll(extractDomainField(offset));
                }
                else
                {
                    rdata.addAll(buff.subList(offset, offset + rdlength));
                    offset += rdlength;
                }

                // We subtract off rdlength so that we don't accidently incur
                //an increase in offset by calling the expandRdata method.
                list.add(Record.recordFactory(name, type, classType, ttl,
                                              rdata));
            }
            // Removes all null elements from this list. Null elements will be
            // returned if record type is not supported.
            while (list.remove(null));
            return list;
        }

      /*  public void ifSoa(RecordType type, List<Byte> tempRdata)
        {
            if (type == RecordType.SOA)
            {
                tempRdata.add((byte) '\t');
                tempRdata.addAll(extractDomainField(offset));
                tempRdata.addAll(buff.subList(offset, offset + SOA_DATA));
            }
        }*/

        public short ifMX(RecordType type, List<Byte> rdata, short rdlength)
        {
            if (type == RecordType.MX)
            {
                rdata.add(buff.get(offset));
                rdata.add(buff.get(offset + ONE_BYTE));
                offset += TWO_BYTES;
                rdlength -= TWO_BYTES;
            }
            return rdlength;
        }


        /**
         * Helper method used to extract domain fields from fields that could
         * contain DNS fields. This is done because these fields require
         * interpretation to put into a true, readable format, and also because
         * some Domain names contain pointers which require unravelling. This
         * must be handled carefully, so as not to overzealously increment our
         * offset counter when examining pointers. In the event the first two
         * bits of a byte in a Domain Name are 11, then it is a pointer.
         * @param tempOffset The current offset to extract teh domain name from.
         * @return Returns the Domain name in byte form, with '.' characters
         *         added in appropriate locations.
         */
        protected List<Byte> extractDomainField(int tempOffset)
        {
            List<Byte> field = new LinkedList<>();
            // If the first two bits of a domain name field byte are 11, then
            // it ias a pointer. Handle by calling followPointer.
            if((buff.get(tempOffset) & DNS_PTR) == DNS_PTR)
            {
                field = followPointer(tempOffset, field);
            }
            else
            {
                field = followLabel(tempOffset, field);
            }
            // If we recurse first, there will always be an extra period at the
            // front. This is a simpler solution than coding all possible places
            // that a period should show up.
            if (field.get(0) == '.')
                field.remove(0);
            return field;
        }

        /**
         * This method is called when a PTR is encountered. It extracts the
         * offset contained by the ptr. If necessary, it increases the global
         * offset, and then calls Label to attempt to read the next label.
         * @param tempOff The current offset we are assuming.
         * @param field The domain field we are unravelling.
         * @return The list of bytes containing the domain name.
         */
        private List<Byte> followPointer(int tempOff, List<Byte> field)
        {
            short ptr = Util.bytesToShort((byte) (buff.get(tempOff) &
                                          DNS_PTR_OFF), buff.get(tempOff + 1));
            assert ptr < offset : "Pointer exceeds offset";
            // If we are working from the top of the list, increase the offset
            // by two.
            if (this.offset == tempOff)
            {
                this.offset += TWO_BYTES;
            }
            field.add((byte) '.');
            return followLabel(ptr, field);
        }

        /**
         * This method attempts to follow a label (domain name) in the buffer
         * and construct a domain name from it.
         * @param tempOff This is the temporary offset we are working from.
         * @param field This is the domain name we are building.
         * @return The list we are building containing the domain name.
         */
        private List<Byte> followLabel(int tempOff, List<Byte> field)
        {
            int newOff = tempOff;
            int size;
            boolean recurse = false;
            int i;
            do
            {
                size = buff.get(newOff);
                newOff += ONE_BYTE;
                if (newOff == offset + 1)
                    offset += 1;
                // End if recurse is true. Pointers can only be at the end of a
                // label.
                for (i = newOff; i < newOff + size && !recurse; i++)
                {
                    // Check if this byte could be a pointer...
                    if ((buff.get(i) & DNS_PTR) == DNS_PTR)
                    {
                        followPointer(i, field);
                        recurse = true;
                    }
                    // Follow label as usual.
                    else
                    {
                        field.add(buff.get(i));
                    }
                }
                if (newOff == offset)
                {
                    offset += size;
                }
                newOff += size;
                // Check if the "Size" byte is a pointer.
                if ((size != 0 && (buff.get(newOff) & DNS_PTR) == DNS_PTR))
                {
                    followPointer(newOff, field);
                    recurse = true;
                }
                // Append '.' character if necessary.
                if (!recurse && size != 0 && buff.get(newOff) != 0)
                    field.add((byte) '.');
            } while(size != 0 && !recurse);
            return field;
        }
    }
}
