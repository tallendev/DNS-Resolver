package edu.wcu.cs.agora.allen.DnsResolver;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.regex.Pattern;

/**
 * A Request object contains the information to be send to the DNS server. It
 * can produce the request in a raw format, a TCP format, and a UDP datagram.
 * @author Tyler Allen
 * @version 10/07/13
 */
public class Request
{
    /** Regex later must escape period, but for now we must escape backslash.
     *  Used to delimit the parts of a domain name. */
    public static String NAME_DELIMITER = "\\.";
    /** The character set we are using to encode/decode. */
    public static Charset CHARSET       = StandardCharsets.UTF_8;
    /** The QCLASS field of the DNS packet will always be the same.*/
    public static byte[] QCLASS         = {0x0000, 0x0001}; //IN
    /** The default well-known DNS port. */
    public static int DNS_PORT          = 53;

    /** This is actually the length of this field as a constant.*/
    public static final int DNS_ID_LEN     = 2;
    /** The size of a byte. */
    public final static int BYTE_SIZE = 8;

    /** Values of these areas of the header.*/
    /** The default value for the QR_RD byte in the header. */
    public static final byte QR_RD     = 0b00000001;
    /** Z field is reserved, RCODE value is 0. */
    public static final byte Z_RCODE   = 0b00000000;
    /** Two byte couple for QD count. We are sending 1 question. */
    public static final byte[] QDCOUNT = {0b00000000, 0b00000001};
    /** Two byte couple for AN count. We are sending 0 answers. */
    public static final byte[] ANCOUNT = {0b00000000, 0b00000000};
    /** Two byte couple for NS count. We are sending zero NS records in the
     * authority section.*/
    public static final byte[] NSCOUNT = {0b00000000, 0b00000000};
    /** Two byte couple for AR count. We are sending zero additional records. */
    public static final byte[] ARCOUNT = {0b00000000, 0b00000000};

    /** The dns address for this request. */
    private String dnsAddr;
    /** The address we are to lookup. */
    private String lookupAddr;
    /** The type of lookup we are performing. */
    private String lookupType;
    /** The INetAddress of the dns server. This lets us take in hostnames for
     *  DNS addresses.*/
    private InetAddress dnsInetAddr;

    /** The randomly generated identifier that we are sending to identify the
     *  packet being returned to us.
     */
    private byte[] identifier;
    private List<Byte> qname;
    private List<Byte> header;

    public Request(String dnsAddr, String lookupAddr, String lookupType)
                   throws UnknownHostException
    {
        this.dnsAddr     = dnsAddr;
        this.lookupAddr  = lookupAddr;
        this.lookupType  = lookupType;
        this.dnsInetAddr = InetAddress.getByName(dnsAddr);

        /* Must happen in this order.*/
        identifier = new byte[DNS_ID_LEN]; //Value of ID
        Random random = new Random();
        random.nextBytes(identifier);

        qname = makeQname();
        header = makeHeader();
    }

    /**
     * Returns the identifier, in bytes.
     * @return The identifier for this request.
     */
    public byte[] getIdentifier()
    {
        return Util.byteArrayCopy(identifier);
    }

    /**
     * Returns a TCP socket based on this request.
     * @return The TCP socket based on this request.
     * @throws IOException Throws socket-based exceptions if there is an issue
     *                      creating the socket.
     */
    public Socket getTcpSocket() throws IOException
    {
        return new Socket(dnsAddr, DNS_PORT);
    }

    /**
     * The rawRequest generated by this Request object.
     * @return The raw request, in byte[] form.
     */
    public byte[] getRawRequest()
    {
        List<Byte> packetList = this.header;
        packetList.addAll(this.qname);
        Util.addBytesToList(packetList,
                            RecordType.typeLookup(lookupType).toByteArray());
        Util.addBytesToList(packetList, QCLASS);
        return Util.unboxBytes(packetList);
    }

    /**
     * The raw request with a 2 byte length appended to the front.
     * @return The newly generated TCP request.
     */
    public byte[] getRawTcpRequest()
    {
        byte[] rawRequest = getRawRequest();
        /* Append a header to the RawRequest specifying the length, as
         * requested in RFC 1035. */
        byte[] rawRequestLen = {(byte) (rawRequest.length >> BYTE_SIZE),
                                (byte) rawRequest.length};
        return Util.combineByteArray(rawRequestLen, rawRequest);
    }

    /**
     * Returns a datagram packet constructed based on this request. It can be
     * sent straight to the DNS server in this form.
     * @return The generated UDP packet.
     */
    public DatagramPacket getRequestPacket()
    {
        byte[] rawRequest = getRawRequest();
        return new DatagramPacket(rawRequest, rawRequest.length, dnsInetAddr,
                                 DNS_PORT);
    }

    /**
     *   0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |                        ID                     |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |QR|   Opcode  |AA|TC|RD|RA| Z      |   RCODE   |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |                     QDCOUNT                   |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |                     ANCOUNT                   |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |                     NSCOUNT                   |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     * |                     ARCOUNT                   |
     * +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
     *
     * The above is a Bit Diagram taken from RFC-1035 for the header of a DNS
     * Packet. This method constructs this header.
     *
     * ID: 2 Byte random ID number. Used when multiple receives are sent.
     *
     * QR - TC: Not used for Request.
     * RD: Recursion. Set to 1 for yes.
     * This Byte's value is 1 due to this.
     *
     * Z-RCODE: Set to 0.
     * This Byte's value is 0 due to this.
     *
     * QDCOUNT: Number of questions. Combined Bytes set to 1.
     * ANCOUNT: Number of answers. Combined Bytes set to 0
     * NSCOUNT: Number of Authority Records. Combined Bytes Set to 0.
     * ARCOUNT: Number of Additional Records. Combined Bytes set to 0.
     *
     * @return A list of Bytes containing the header.
     */
    private List<Byte> makeHeader()
    {
        ArrayList<Byte> header = new ArrayList<>();
        Util.addBytesToList(header, identifier); //ID
        header.add(QR_RD); //Value of QR-RD.
        header.add(Z_RCODE); //value of Z-RCODE
        Util.addBytesToList(header, QDCOUNT); //Value of QDCOUNT
        Util.addBytesToList(header, ANCOUNT); //Value of QDCOUNT
        Util.addBytesToList(header, NSCOUNT); // value of NS Count
        Util.addBytesToList(header, ARCOUNT); //Value of AR Count
        return header;
    }

    /**
     * The QNAME section of the DNS request is generated by this method. We
     * split up the domain by periods and substitute the length of the parts.
     * @return The generated QNAME.
     */
    private List<Byte> makeQname()
    {
        String[] sets = Pattern.compile(NAME_DELIMITER).split(lookupAddr);
        List<Byte> qname = new ArrayList<>();
        for(String section : sets)
        {
            qname.add((byte) section.length());
            Util.addBytesToList(qname, section.getBytes(CHARSET));
        }
        qname.add((byte) 0b00000000);
        return qname;
    }
}
